//: [Previous](@previous)

import Foundation

/*
                               РАСШИРЕНИЯ(extension)

 Расширения – предоставляет возможность добавить новую функциональность к уже существующему
 объектному типу:
 - классу
 - структуре
 - перечислению
 - протоколу

 
 Для объявления расширения используется ключевое слово extension, после которого               указывается имя расширяемого типа данных.
 
    extension ИмяРасширяемогоТипа {
        // описание новой функциональности для расширяемого типа
    }
 
 Расширения часто используют, чтобы разделить функциональность в коде, и не сваливать все в
 кучу в один тип данных.

 
                             ВЫЧИСЛЯЕМЫЕ СВОЙСТВА

 Расширения могут добавлять вычисляемые свойства экземпляра и вычисляемые свойства типа в уже существующий объектный тип.

 Расширения могут добавлять только новые вычисляемые свойства. При попытке добавить хранимые свойства или наблюдателей свойств
 происходит ошибка.

 Ваша программа оперирует расстояниями и использует для этого значения типа Double. По умолчанию такое значение определяет расстояние в метрах, но вам требуется организовать оперативный перевод метров в другие единицы измерения расстояний. Для этого расширим тип данных Double и добавим в него несколько специальных вычисляемых свойств
*/

 extension Double {
     var asKM: Double { return self / 1000.0 }
     var asM: Double { return self }
     var asCM: Double { return self * 100.0 }
     var asMM: Double { return self * 1000.0 }
 }

 //Для перевода расстояние из метров в другие единицы  воспользуемся одним из свойств

 let length: Double = 25       // метров
 length.asKM                   // в километрах
 length.asMM                   // в миллиметрах


 //Применение set & get для вычеляемых сво-в

 extension Double {
     var asFT: Double {
         get {
             return self / 0.3048
         }
         set(newValue) {
             self = newValue * 0.3048
         }
     }
 }

 var distance: Double = 100           // расстояние 100 метров
 distance.asFT                        // в футах

 // установим расстояние в футах, но оно будет сохранено в метрах
 distance.asFT = 150

/*
                                МЕТОДЫ В РАСШИРЕНИЯХ

 Расширения могут добавлять в объектные типы не только свойства, но и методы.
 Пример в котором расширяется тип Int.
 В нем появился новый метод repetitions, принимающий на входе замыкание типа () -> ().
 
 Данный метод предназначен для того, чтобы выполнять переданное замыкание столько раз,
 сколько указывает собственное значение целого числа.
*/
 extension Int {
     func repetitions(task: () -> ()) {
         for _ in 0..<self {
         task()
         }
     }
 }

 3.repetitions {
     print("Swift")
 }

/*
 Для изменения свойств перечислений (enum) и структур (struct) не забывайте использовать
 модификатор #mutating.
 
 Ниже в расширении объявляется метод square(), который возводит в квадрат собственное
 значение экземпляра.
 
 Так как тип Int является структурой, то для изменения собственного значения экземпляра
 необходимо использовать ключевое слово mutating.
*/
 extension Int {
     mutating func squared() {
         self = self * self
     }
 }
 var someInt = 3
 someInt.squared()

/*
                                 ИНИЦИАЛИЗАТОРЫ В РАСШИРЕНИЯХ

 Благодаря расширениям появляется возможность добавлять новые инициализаторы к существующему объектному типу.
 Так, вы можете расширить типы, например, для обработки экземпляров ваших собственных типов в качестве входных аргументов.

 Для классов расширения могут добавлять только новые вспомогательные инициализаторы. Попытка добавить назначенный
 инициализатор или деинициализатор приведет к ошибке.

 В качестве примера создадим структуру Line, описывающую линию на плоскости.
 С помощью расширения реализуем инициализатор типа Double, принимающий на вход экземпляр данной структуры и устанавливающий
 значение, соответствующее длине линии
*/

 struct Line {
     var pointOne: (Double, Double)
     var pointTwo: (Double, Double)
 }

 extension Double {
       init(line: Line) {
         self = sqrt(
             pow((line.pointTwo.0 - line.pointOne.0), 2) +
             pow((line.pointTwo.1 - line.pointOne.1), 2)
         )
      }
 }

 var myLine = Line(pointOne: (10,10), pointTwo: (14,10))
 var lineLength = Double(line: myLine)

/*

 Структура Line описывает сущность «линия», в свойствах которой указываются координаты точек ее начала и конца.
 Созданный в расширении инициализатор принимает на входе экземпляр класса Line и на основе значений его свойств вычисляет
 требуемое значение.

 При разработке нового инициализатора в расширении будьте крайне внимательны, чтобы к завершению инициализации каждое из
 свойств расширяемого типа имело определенное значение.
 Например, если вы напишете расширение уже для типа Line, но в нем проинициализуете значение только для одного из свойств
 этого типа, это приведет к ошибке.

 
 
 
 
                                    РАСШИРЕНИЕ ПРОТОКОЛОВ

 Рассмотрим возможности совместного использования расширений и протоколов.
 Подпись объектного типа на протокол

 С помощью расширений у вас есть возможность подписать существующий тип на определенный протокол.
 Для этого в расширении после имени типа данных через двоеточие необходимо указать список новых протоколов.
 Ниже тип данных Int подписывается на протокол TextRepresentable, который требует наличия метода asText().
 
 С помощью расширения мы добавляем требование о соответствии типа протоколу, при этом обязательно указывается реализация
 метода.

 Расширение протоколов и реализации по умолчанию

 Расширения могут расширять не только конкретные типы данных, но и протоколы.
 При этом они позволяют указать реализацию по умолчанию для любого метода этого протокола
 
*/

 protocol Descriptional {
     func getDescription() -> String
 }
 // расширение протокола и указание реализации метода по умолчанию
 extension Descriptional {
     func getDescription() -> String {
         return "Описание объектного типа"
     }
 }

 // подпишем класс на протокол
 class myClass: Descriptional { }
 print(myClass().getDescription())

/*
 Несмотря на то что в классе myClass отсутствует реализация метода getDescription(), при его вызове не появляются сообщения об
 ошибках. Это связано с тем, что протокол имеет реализацию метода по умолчанию, описанную в его расширении.

 Реализация методов по умолчанию для протоколов доступна только при использовании расширений. Вы не можете наполнить метод
 непосредственно при объявлении протокола.

 При этом вы всегда можете переопределить реализацию по умолчанию непосредственно в самом объектном типе
*/

 class myStruct: Descriptional {
     func getDescription() -> String {
         return "Описание структуры"
     }
 }
 myStruct().getDescription() // "Описание структуры"

/*
 Реализация методов по умолчанию, а также множественное наследование протоколов являются основой методологии
 протокол-ориентированного программирования. С помощью расширений вы можете расширять и сами протоколы.

 При объявлении расширения необходимо использовать имя протокола, а в его теле указывать набор требований с их реализациями.
 После расширения протокола описанные в нем реализации становятся доступны в экземплярах всех классов, которые приняли данный
 протокол к реализации. Напишем расширение для реализованного ранее протокола TextRepresentable
*/

 protocol TextRepresentable {
     func asText() -> String
 }
 extension Int: TextRepresentable {
     func asText() -> String {
         return String(self)
     }
 }
 5.asText()

 extension TextRepresentable {
     func about() -> String {
         return "Данный тип поддерживает протокол TextRepresentable"
     }
 }

 5.about()

/*
 Расширение добавляет новый метод в протокол TextRepresentable.
 При этом ранее мы указали, что тип Int соответствует данному протоколу.
 В связи с этим появляется возможность обратиться к указанному методу для любого значения
 типа Int.
*/

//: [Next](@next)
